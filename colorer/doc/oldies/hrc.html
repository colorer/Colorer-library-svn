<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Синтаксис hrc-скриптов библиотеки colorer</title>
<link rel="stylesheet" type="text/css" href="../styles/styles.css">
</head>
<body>

<h1>Синтаксис hrc-скриптов библиотеки colorer</h1>


<h2>вместо введения</h2>
<p>
HRC - это формат хранения описаний синтаксиса языков программирования,
скриптов и другой структурированной текстовой информации. Он используется
в библиотеке колорер для синтаксического разбора и расцветки целевого
текста. В общем-то, это довольно сложный скриптовый язык с мощными возможностями
описания синтаксиса. hrc основан на метаязыке xml, и все его описания хранятся
именно в этом формате. В поставке колорера вы найдете специально для этого
описания синтаксиса hrc в DTD (hrc.dtd) и стилевые таблицы преобразования
в html (hrc.xsl).
</p>
<p>
Для того чтобы полностью понять hrc, вам надо было его создать,
но в общем-то можно &laquo;врубиться&raquo; и на халяву. Перво-наперво
вы должны понять для чего собственно нужен hrc, и как в базовом виде он работает.
Поэтому предварительно почитайте еще документацию по регулярным выражениям
колорера - <a href="cregexp.html">cregexp.html</a>.
Сразу буду предполагать, что слова xml (или html) вы не пугаетесь - ну
а если пугаетесь, то откройте любой hrc файл и окиньте взглядом.
Если вы программист или около того, то, в общем-то, идею поймете быстро.
Ну а если не поняли - &laquo;Плюньте на это, Киса&raquo;.
</p>
<p>
Перед тем, как все описывать, давайте прикинем общую систему скриптов.
Пускай в упрощенном варианте у нас каждый язык описывается некоторым блоком -
назовем его <b>схемой (scheme)</b>. То есть, к примеру, есть схема языка C/C++,
Pascal, Perl... Далее, каждой такой языковой схеме сопоставим блок типа языка
(<b>type</b>) - в нем будет храниться дополнительная информация о нашем языке.
К примеру, расширения файлов этого типа (если у файла нет фиксированного
расширения, там же будет храниться возможность определения этого типа по первой
строчке файла). Здесь же будет содержаться описание языка - для вывода
пользователю, ну и так далее. Описания всех типов пусть хранятся в одном
файле (они занимают мало места), а вот схемы языков пусть лежат в своих файлах.
Как теперь мы будет загружать схемы? Можно загрузить все схемы сразу (положим
перечислив их все в этом же главном файле) - но если схем много, то это будет не
эффективно. Давайте в каждом типе еще указывать, файл с какими схемами этому типу
требуется. Таким образом, когда пользователь откроет конкретный файл, колорер
выберет нужный тип файла по расширению и только тогда загрузит необходимые
этому типу файла схемы. Вот так вот в общем виде.
</p>

<h2>фортам (именно фортам) hrc</h2>

<p>В базе колорера hrc файлов очень много, но все они имеют один формат.
Содержимое любого файла выглядит более-менее стандартно:
<pre>
<font color=#c4c400>&lt;?</font><font color=#0689ff>xml</font><font color=#c4c400> version</font><font color=#86cdd2>=</font><font color=#c4c400>"1.0"</font><font color=#c4c400> encoding</font><font color=#86cdd2>=</font><font color=#c4c400>"Windows-1251"</font><font color=#c4c400>?&gt;</font>
<font color=#0689ff>&lt;!</font><font color=#9391ec>DOCTYPE</font> hrc <font color=#0c8164>SYSTEM</font> <font color=#c4c400>"hrc.dtd"</font><font color=#0084fb>&gt;</font>
<font color=#c4c400>&lt;?</font><font color=#0689ff>xml-stylesheet</font><font color=#c4c400> type</font><font color=#86cdd2>=</font><font color=#c4c400>"text/xsl"</font><font color=#c4c400> href</font><font color=#86cdd2>=</font><font color=#c4c400>"hrc.xsl"</font><font color=#c4c400>?&gt;</font>
<font color=#696969>&lt;!--</font>
<font color=#696969>     комментарии создателя</font>
<font color=#696969>--&gt;</font>
<font color=#6051e6>&lt;hrc</font> version<font color=#86cdd2>=</font><font color=#c4c400>"4ever"</font><font color=#6051e6>&gt;</font>

<font color=#696969>&lt;!-- основное содержимое --&gt;</font>

<font color=#6051e6>&lt;/hrc&gt;</font>
</pre>

<p>
первые три строчки - это стандартные включения xml, а вот в блоке &lt;hrc>
и лежат все основные определения. Заметьте, что параметр <code>version</code>
не обязателен и есть только в главном файле, к которому мы сейчас и перейдем.
</p>

<h3>colorer.hrc</h3>
<p>
Это базовый файл, в котором находятся определения всех типов и подключаются
нужные схемы.
Вот кусок этого файла:
<pre>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;include </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>regions.hrc</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;include </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>defines.hrc</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font>

<font color=#ee00ee>  </font><font color=#9391ec>&lt;type</font><font color=#ee00ee> </font><font color=#0c8164>descr</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>c++</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>cpp</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>exts</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#808000>\.</font><font color=#ffae7d>(</font><font color=#c4c400>cpp</font><font color=#ffae7d>)</font><font color=#ffae7d>|</font><font color=#ffae7d>(</font><font color=#c4c400>cxx</font><font color=#ffae7d>)</font><font color=#ffae7d>|</font><font color=#ffae7d>(</font><font color=#c4c400>cc</font><font color=#ffae7d>)</font><font color=#ffae7d>|</font><font color=#ffae7d>(</font><font color=#c4c400>hpp</font><font color=#ffae7d>)</font><font color=#ffae7d>|</font><font color=#c4c400>h</font><font color=#ffae7d>$</font><font color=#ffae7d>/i"</font><font color=#9391ec>&gt;</font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;load</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>base/cpp.hrc</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>cpp</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;/type&gt;</font><font color=#ee00ee></font>
</pre>
<p>Здесь используется тэг
<font color=#ee00ee>  </font><font color=#9391ec>&lt;include </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>filename.hrc</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font>
Это часто используемый в определениях тэг указывает колореру о необходимости подключить файл с именем
filename.hrc. Заметьте, что файл подключается безусловно, то есть если вы укажете
<code>&lt;include name="base/c.hrc"></code>, то файл со схемой Си загрузится безо всяких
отлагательств.

<p>Далее, тэг &lt;type ..> создает отдельный тип файла. В нашем случае это
язык C++. Заметьте, что поле <code>descr</code> задает описание языка для
отображения пользователю, а параметр <code>name</code> задает уникальное системное имя
типа. Далее, параметр <code>exts</code> указывает регулярное выражение в формате
колорера (cregexp), которое распознает имя файла C++.
<p>Внутри тэга type мы имеем тэг
<font color=#ee00ee>    </font><font color=#9391ec>&lt;load</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>base/cpp.hrc</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
,который указывает колореру, в каком файле искать саму схему языка C++.
таких тэгов scheme может быть несколько - тогда колорер загрузит все указанные файлы.
Ну и наконец, в тэге
<font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>cpp</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
указывается имя схемы, которую надо использовать для расцветки языка C++.
Заметьте, что здесь оно совпадает с именем типа. Это не обязательно - но рекомендуется
правилами написания hrc.
<p>В тэге type может использоваться и параметр switch:
<pre>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;type</font><font color=#ee00ee> </font><font color=#0c8164>descr</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>default</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>default</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>exts</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>/"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;switch</font><font color=#ee00ee> </font><font color=#0c8164>type</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>messages</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>match</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>^</font><font color=#c4c400>from</font><font color=#ffae7d>/i"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;switch</font><font color=#ee00ee> </font><font color=#0c8164>type</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>diff</font><font color=#ffae7d>"</font><font color=#ee00ee>     </font><font color=#0c8164>match</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>^</font><font color=#ffae7d>(</font><font color=#c4c400>diff</font><font color=#ffae7d>)</font><font color=#ffae7d>|</font><font color=#ffae7d>(</font><font color=#c4c400>---</font><font color=#ffae7d>)</font><font color=#ffae7d>/i"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;/type&gt;</font><font color=#ee00ee></font>
</pre>

<p>Этот параметр указывает колореру, что если файл этого типа имеет первую строчку,
которая совпадает с регулярным выражением match, то необходимо переключиться на
тип, указанный в параметре <code>type</code>. Заметьте, что в этом параметре указывается
не описание типа - а его системное имя (name).
<p>В описанном выше случае, если выбирается тип default (то есть файл не попадает
ни под один ранее определенный тип), и первая строчка содержит символы diff или
---, то произойдет выбор не типа default, а типа <code>diff</code>.

<h2>основное содержимое hrc</h2>
<p>
Забыл я еще сказать об одном маленьком тэге -
<pre>
<font color=#9391ec>&lt;define </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dNumber</font><font color=#ffae7d>"</font><font color=#ee00ee>    </font><font color=#0c8164>value</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>10</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
</pre>
Этот тэг определяет цветовой регион с именем dNumber, присваивая ему значение 10.
Цветовой (или точнее пока синтаксический) регион определяет одну изолированную
лексему в файле. К примеру здесь это число. Этот можно использовать и по-другому:
<pre>
<font color=#9391ec>&lt;define </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dNumHex</font><font color=#ffae7d>"</font><font color=#ee00ee>    </font><font color=#0c8164>value</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dNumber</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
</pre>
Здесь новый регион dNumHex определится через dNumber. Пока можно представлять, что
регионы это обычные цвета. А почему это не совсем правильно я объясню чуть позже.

<p>
Ну, теперь надо говорить об основном блоке любого hrc файла - блоке
<code>&lt;scheme></code>
Этот блок и определяет конкретную схему языка, то есть тот элемент, который
производит разбор.
Внутри этого блока определяются конкретные элементы, отвечающие за разбор текста
и его расцветку. Начнем от простого к сложному.

<h3>блок keywords</h3>

<p>
Этот блок определяет набор ключевых слов, которые будут выделяться как определенные
лексемы:

<pre>
  <font color=#9391ec>&lt;keywords</font><font color=#ee00ee> </font><font color=#0c8164>region</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dKeyWord</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>ignorecase</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>ignorecase</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>worddiv</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>[</font><font color=#c4c400>^</font><font color=#808000>\w</font><font color=#c4c400>_</font><font color=#ffae7d>]</font><font color=#ffae7d>/"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
  <font color=#ee00ee>   </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>asm</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
  <font color=#ee00ee>   </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>auto</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
  <font color=#ee00ee>   </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>break</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
  <font color=#ee00ee>   </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>case</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
  <font color=#ee00ee>   </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>cdecl</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
  <font color=#ee00ee>   </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>char</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
  <font color=#ee00ee>   </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>const</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
  <font color=#ee00ee>   </font><font color=#9391ec>&lt;symb</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>-&gt;</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
  <font color=#9391ec>&lt;/keywords&gt;</font><font color=#ee00ee></font>
</pre>

<p>вложенные в него тэги word задают выделение слов (то есть строк, которые
имеют границами переходы с символа слова на неслово), а тэги <code>symb</code>
задают выделение символов - то есть игнорируют границы выделяемой лексемы.
параметр <code>region</code> в блоке keywords используется для указания
региона, сопоставляемого указанным ключевым словам. Такой же параметр можно
указывать и непосредственно у каждого тэга word или symb.
Еще один параметр - <code>worddiv</code>, задает класс символов, которые
считаются символами-разделителями слов. В большинстве случаев этот параметр
можно не указывать - по умолчанию разделителями считаются все символы кроме
символов слова(букв, цифр), и символа подчеркивания.
<p>Последний параметр этого блока - <code>ignorecase="ignorecase"</code>
указывает колореру, что все слова в этом блоке надо искать без учета регистра
символов.

<h3>regexp</h3>
<p>
Этот тэг используется для определения базового регулярного выражения для
разбора и выделения синтаксиса. Он может обрабатывать произвольные
синтаксические конструкции - но в пределах одной строки файла.
Выглядит он примерно так:

<pre>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;regexp</font><font color=#ee00ee> </font><font color=#0c8164>match</font><font color=#9391ec>=</font><font color=#ffae7d>'/</font><font color=#c4c400>"</font><font color=#ffae7d>.</font><font color=#ffae7d>*</font><font color=#ffae7d>?</font><font color=#c4c400>"</font><font color=#ffae7d>/'</font><font color=#ee00ee> </font><font color=#0c8164>region0</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dString</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;regexp</font><font color=#ee00ee> </font><font color=#0c8164>match</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#c4c400>'</font><font color=#ffae7d>.</font><font color=#ffae7d>*</font><font color=#ffae7d>$</font><font color=#ffae7d>/"</font><font color=#ee00ee>  </font><font color=#0c8164>region0</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dComment</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;regexp</font><font color=#ee00ee> </font><font color=#0c8164>match</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>\b</font><font color=#ffae7d>[</font><font color=#c4c400>0</font><font color=#ffae7d>-</font><font color=#c4c400>9.</font><font color=#ffae7d>]</font><font color=#c4c400>+</font><font color=#ffae7d>(</font><font color=#c4c400>e</font><font color=#ffae7d>|</font><font color=#c4c400>E</font><font color=#ffae7d>[</font><font color=#808000>\-</font><font color=#c4c400>+</font><font color=#ffae7d>]</font><font color=#ffae7d>?</font><font color=#ffae7d>\d</font><font color=#c4c400>+</font><font color=#ffae7d>)</font><font color=#ffae7d>?</font><font color=#ffae7d>\B</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>region0</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dNumber</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
</pre>

<p>Первый его параметр (и единственный обязательный) это регулярное выражение
<code>match</code>. Это регулярное выражение сопоставляется с каждой позицией
строки. В случае совпадение, происходит синтаксическое выделение в соответствии
с параметрами <code>regionX</code>, где X - числа от 0 до F. Каждый i-й регион
указывает каким регионом (ну или цветом) выделить соответствующуу i-ю скобку
в регулярном выражении. region0 всегда соответствует всему регэкспу.

<h3>block</h3>
<p>
Это основной тэг, который позволяет языку hrc создавать очень сложные языковые
конструкции, хотя для понимания он довольно прост.

<pre>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;block</font><font color=#ee00ee> </font><font color=#0c8164>start</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#808000>\/</font><font color=#808000>\*</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>end</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#808000>\*</font><font color=#808000>\/</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>Comment</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>          </font><font color=#0c8164>region</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>cComment</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region00</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dpOpenStruct</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region10</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dpCloseStruct</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
</pre>

<p>У этого тэга первые два параметра <code>start</code> и <code>end</code>
являются так же регулярными выражениями, и определяют начало и окончание выделяемого
блока. Третий обязательный параметр <code>scheme</code> задает имя схемы, на
которую нужно переключиться между этими началом и концом. В указанном случае
наш блок определяет обычный многострочный комментарий языка Си/Си++. Иными словами
этот блок говорит, &laquo;Вот я встретил сочетание /* - так что начну дальше
все выделять новой схемой "Comment" - пока не встречу сочетание */&raquo;

<p>А схема Comment - это просто пустая схема (ведь в комментарии ничего не надо
выделять). С другой стороны вставьте в эту схему определение регэкспа, выделяющего
число (я указывал его выше) - и все числа, которые будут внутри комментария
выделятся.
<p>Для цветового выделения у тэга block существует рабор параметров regionXX.
Отдельно стоящий параметр <code>region</code> задает цвет выделения всего этого
блока - от начала до конца. А вот параметры region0i и region1j - задают
выделение i-х скобок в тэге start и j-х скобок в тэге end. Как и в тэге regexp
region00 и region10 используются для выделения всего регэкспа start или end, а все,
начиная с единицы, выделяют соответствующую по номеру скобку
Вообще, умелое использование этого тэга может дать поразительные результаты - об
этом я расскажу чуть ниже.

<h3>inherit</h3>
<p>Это самый интеллектуальный тэг - с его помощью можно
на порядок облегчить себе работу (хотя можно обойтись и без него).
Тэг inherit задает схему, от которой текущая схема наследует все свойства -
то есть ключевые слова, регулярные выражения, блоки и другие наследования.
Чтобы проще понять,

<pre>
<font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>Comment</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;inherit </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>mNetEMail</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;inherit </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>mNetURL</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#9391ec>&lt;/scheme&gt;</font><font color=#ee00ee></font>
</pre>

<p>вот определяется схема комментарий (Comment). Раньше я говорил что она
пустая - но она не совсем пустая. В комментариях удобно выделять почтовые
адреса - чего здесь и делается.
Но для этого они не описываются заново через тэги <code>regexp</code>, а просто
наследуются из уже существующих схем. Фактически, эти две строчки эквивалетны тому,
что вы скопируете содержимое наследуемых схем в эту схему.
Теперь понимаете, как это облегчает труд, если надо наследовать свойства большой
схемы? К примеру язык Си++ - это Си с некоторыми дополнительными ключевыми словами.
Но вместо полного переписывания схемы копированием мы просто наследуем в языке
Си++ язык Си. Заметьте, что при этом даже в памяти (внутри колорера) копирования
не происходит - за счет чего уменьшается и объем hrc кодов и объем используемой
памяти.

<h3>Усредненное представление</h3>
<p>
Так. Ну и что же мы имеет на данный момент?
Как вы могли догадаться, схема, ссылаясь на другие схемы, определяет тем
самым сложную структуру взаимодействия внутри hrc-кодов. О ней милой и поговорим.
Во-первых, сразу предостерегу: явно поймите различия между включением схемы и
наследованием ее. И то и другое на уровне кодов - рекурсия, но первое - это
рекурсия вынужденная, а второе - рекурсия явная.
<p>Иными словами рекурсия блоков определяется содержимым целевого файла, а
рекурсия наследования всегда одна и та же. Из этого следуют весьма интересные
логические выводы. В блоке вы можете вызвать схему, которая еще не была определена
и скомпилирована - а та схема, в свою очередь может вызвать первую схему - и так
далее. И заметьте, при этом не будет зацикливания колорера - потому что цикличность
эта задается в целевом тексте - а в нем блоки не могут быть бесконечно вложены друг
в друга (текст-то конечен). Более того, можно создать блок, который будет вызывать
схему, в которой он определен! И здесь нет ничего странного - таким образом, например,
элементарно определяются вложенные комментарии в Си стиле.

<p>Другое дело с наследованием. Если я наследую схему, которая еще не определена,
а она наследует меня, то чего же будет? Никакой логики. И правильно - потому что
будет мгновенное зацикливание парсера. Поэтому и нельзя наследовать еще
неопределенную схему (есть интересные исключения - можно
&laquo;заставить&raquo; другую схему наследовать любую схему - но это позже).
Такие наглые попытки просто пресекаются колорером.

<p>Может кому-то показаться на примитивном уровне, что схемы не так то уж нужны.
Бросьте в него камень. Нет такой схемы в hrc кодах, где бы ни встречался тэг блочной
структуры. Начиная от элементарных блоков комментариев, и кончая сложными
системами взаимодействия схем в xml-кодах - везде используется наследование как
механизм обобщения и изменения свойств, и вызовы блоков как механизм реализации
разбора сложных структур языков.

<p>Теперь видно, что каждому языку (типу) может соответствовать не одна схема.
А некоторые языки вообще работают на основе схем различных языков, объединяя и
обобщая их (хотя те даже об этом не подозревают). Все это делается путем
активного применения механизма наследования. В совокупности с механизмом
виртуализации, о котором будет сказано ниже, его можно сравнить с
наследованием классов в Объектно-Ориентированных языках программирования.

<p>Причем это очень элегантное Объектно-Ориентированное программирование.
Ведь в сущности своей ООП предназначено для создания красивой внутренней структуры
программы - оно помогает не пользователю, а программисту. Согласитесь, что
любую объектно-ориентированную программу на том же Си++ можно переписать и в
другом виде. Вот только насколько это будет выгоднее... Более того, ООП важно
не в виде конечной реализации, а внутри программы, в самой идее, логике работы.
Если программа требует постоянного изменения, переделывания, устранения
несовместимостей самой с собой, то какой бы язык не использовался при ее написании -
она не будет объектно-ориентированной.
И с другой стороны, программа, написанная даже на ассемблере, может выражать
красивые и элегантные архитектурные идеи - лишь из своей структуры работы.
Язык часто ограничивает поток мысли - у него не хватает классов, лексем и
операторов.

<p>Само по себе ООП - это не только ключевые слова <code>class</code>,
<code>public</code>, <code>protected</code> и <code>virtual</code>.

Что такое инкапсуляция? Фредерик Брукс сказал, а Эрик Реймонд
перефразировал:
"Покажите мне код, не показывая своих структур данных и я по-прежнему
буду пребывать в заблуждении. Покажите мне свои структуры данных и, как
правило, ваш код мне не понадобиться; и так все будет понятно".

<p>Инкапсуляция, как выражение дуализма кода и данных. Что такое в
колорере весь hrc? Да всего лишь набор списков списков списков структур -
но он не зависит от парсера в явном виде. Объем hrc-кодов в 20000 строк
обрабатывается парсером размером в 500 строк. hrc инкапсулирует, объединяя
всю логику работы и представляя коды по синтаксическому анализу.
Очень важно в сложных языках до мелочей понимать логику взаимодействия
различных схем. Особенно это необходимо будет при применении механизма
виртуализации схем.



<h3>Предварительное заключение</h3>
<p>
Ну, если вы чего-нибудь из этого поняли, то это хорошо. Дальше я начну объяснять
некоторые более глубокие свойства hrc, поэтому если показанную выше структуру
hrc вы расплывчато представляете, то попробуйте посмотреть примеры.
Первым делом сам <code>colorer.hrc</code>, <code>defines.hrc</code> - там
определяется набор простеньких схемок - макросов, <code>regions.hrc</code> -
в этом файле определяются все встроенные лексемы - только они используются
в цветовых определениях.
<p>Попробуйте посмотреть простенькие скрипты - навроде
<code>config/litestep.hrc</code> - на них можно понять основные свойства.


<h2>Расширенные свойства межсхемных взаимодействий</h2>
<p>Здесь мы рассмотрим понятия границ регулярных выражений, границ схем,
которые очень важны при более тонкой настройке языков, а так же понятие
приоритетов регулярных выражений.

<h3>Границы</h3>
<p>Итак, первое - границы.
Если внимательно читали <a href="cregexp.html">cregexp.html</a> (а его
вы должны были прочитать прежде чем лезть сюда), то наверное заметили
странные параметры (метасимволы \m и \M), задающие смену начала и
окончания (скажем мягко) регулярного выражения. Эти параметры могут использоваться
как в блоках, так и в одиночных регулярных выражениях. Какую роль они играют?
<p>Первая - довольно простая. Помните, я говорил про region00 (region0 для regexp)?
Этот регион сопоставляется не со скобкой, а со всем регулярным выражением.
Так вот по умолчанию все регулярное выражение - это и есть все регулярное выражение -
то есть от начала своего до конца. А вот параметрами \m (начало) и \M (конец)
вы можете явно указать эти границы. Причем ни на какие другие параметры этого регэкспа
это изменение влиять не будет.
<p>Ну это было просто. А теперь о влиянии, которое оказывают эти параметры
на разбор. В обычном однострочном <code>regexp</code>, если вы сместите влево
конец регулярного выражения, то все будет по старому (то есть расцветится оно
по-старому), но вот дальнейший анализ начнется именно с точки нового окончания.
Иными словами с этим параметром регэксп как бы может отдавать часть
себя (а именно свой конец - как это плохо не звучит) на разбор парсеру - то есть
другим элементам схемы. Будет происходить наложение - или же это можно
охарактеризовать как &laquo;прозрачный регэксп&raquo;. К примеру, в языке Паскаль
ищется определение функции. Это сложный регэксп, он может включать в себя
разные ключевые слова, символы там... ну кучу всего. Если вы найдете функцию
и успокоитесь, то например ключевое слово возвращаемого значения этой функции
больше не выделится. Точно так же не выделяются скобки и другие символы. А это
непорядок. Что делать? вы смещаете конец регулярного выражения в самое его
начало и тем самым отдаете парсеру все эти недовыделенные ключевые слова:

<pre>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;regexp</font><font color=#ee00ee> </font><font color=#0c8164>match</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>^</font><font color=#c4c400> </font><font color=#808000>\s</font><font color=#ffae7d>*</font><font color=#c4c400> </font><font color=#808000>\M</font><font color=#c4c400> </font><font color=#ffae7d>(</font><font color=#c4c400>procedure</font><font color=#ffae7d>)</font><font color=#ffae7d>|</font><font color=#ffae7d>(</font><font color=#c4c400>function</font><font color=#ffae7d>)</font><font color=#c4c400> </font><font color=#808000>\s</font><font color=#c4c400>+ </font><font color=#ffae7d>(</font><font color=#ffae7d>[</font><font color=#c4c400>_</font><font color=#808000>\w</font><font color=#ffae7d>]</font><font color=#c4c400>+</font><font color=#ffae7d>)</font><font color=#ffae7d>/ix"</font><font color=#ee00ee> </font><font color=#0c8164>region3</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dFunction</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
</pre>

<p>
Параметр \m, кстати, относительно потока парсинга не играет никакой
роли (вопреки бытующему мнению). В дальнейшем, когда я буду говорить о работе
блоков, под границами любых регулярных выражений я буду понимать или же границы
по-умолчанию, или же границы, явно установленные параметрами \m \M. Вся тонкая работа
по настройке работы схем в сложных случаях должна учитывать границы выражений и схем
как определяющую компоненту в анализе текста.

<p>
Итак, как же происходит работа в сложных схемных структурах с точки зрения учета
границ? В блоке start аналогично обычному регэкспу парсером учитывается
только его окончание - начиная с этого места ведется анализ вложенной схемы этого
блока. Как происходит разбор дальше и, что самое интересное, как происходит
возврат в родительскую схему? Здесь все очень завязано с понятием приоритета
регулярного выражения и приоритета блока. По умолчанию, если вы сами ничего не
указываете, приоритет regexp и block - высокий. Вот и рассмотрим работу &laquo;по умолчанию&raquo;
<p>
Итак, у нас работает вложенная схема, и каким-то образом нам надо поймать
окончание этой схемы. Предположим, что в конце строки находится тот самый
наш долгожданный конец блока - но до него еще есть довольно много регулярных
выражений и даже не исключено что других блоков. Что происходит? Анализ
в этом случае ведется вплоть до окончания нашего родительского блока. Но!
Если вдруг найдется регэксп или блок, который на самом краю либо совпадет
с ним, или же, недоходя до него, заглотит его:
<pre>
  К примеру если есть окончание блока "}", а во вложенном блоке определен
  комментарий в Си стиле, то иллюстрация будет такая:
  // any text....     } - ou - our end bracket!
</pre>

<p>
то произойдет так называемый откат - то есть продолжится анализ этой же вложенной
схемы, и наше старое окончание будет искаться дальше. И так пока
парсер не найдет чистую закрывающую скобку.

<p>
Чтобы это предотвратить, нужно воспользоваться параметром понижения приоритета.
И в <code>regexp</code>, и в <code>block</code> этот параметр выглядит как
<code>lowpriority="lowpriority"</code>. Теперь, если в указанном примере в
регулярном выражении, определяющем комментарий, мы вставим этот параметр,
то комментарий выделится только до конца нашей фигурной скобки, и управление
вернется родительскому блоку. Для регэкспов с пониженным приоритетом
наша закрывающая скобка будет эдаким псевдо-концом строки.

<p>А причем же здесь границы регэкспов? А вот именно границы и определяют то,
когда откат будет происходить а когда не будет. Если границы регэкспа и блока
end перекрываются, то будет откат. Иначе нет. Из-за этого, прошу заметить,
в параметре end важны обе позиции: как начальная (\m) так и конечная (\M).

<p>
Как пример всей этой болтовни можно привести такой код:

<pre>
<font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>xslTags</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;keywords</font><font color=#ee00ee> </font><font color=#0c8164>region</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>xmlOpenTag</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>     </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>apply-imports</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>     </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>apply-templates</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>     </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>attribute</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>     </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>attribute-set</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>     </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>call-template</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;/keywords&gt;</font><font color=#ee00ee></font>
<font color=#9391ec>&lt;/scheme&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee></font>
<font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>xslTagList</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;block</font><font color=#ee00ee> </font><font color=#0c8164>start</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>\b</font><font color=#ffae7d>(</font><font color=#c4c400>xsl</font><font color=#ffae7d>)</font><font color=#ffae7d>(</font><font color=#808000>\:</font><font color=#ffae7d>)</font><font color=#c4c400> </font><font color=#808000>\M</font><font color=#c4c400> </font><font color=#ffae7d>[</font><font color=#808000>\w</font><font color=#808000>\-</font><font color=#ffae7d>]</font><font color=#c4c400>+</font><font color=#ffae7d>/ix"</font><font color=#ee00ee> </font><font color=#0c8164>end</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>~</font><font color=#ffae7d>[</font><font color=#808000>\w</font><font color=#808000>\-</font><font color=#ffae7d>]</font><font color=#c4c400>+</font><font color=#808000>\m</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>xslTags</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>          </font><font color=#0c8164>region01</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>xmlNameSpace</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region02</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dSymb</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#9391ec>&lt;/scheme&gt;</font><font color=#ee00ee></font>

</pre>

<p>Положим у нас есть очень много ключевых слов, начинающихся с символов "xsl:".
xsl:apply-template, xsl:attribute, и так далее.
Конечно их можно перечислить и так, но нас в данном случае интересует
исследовательская сторона проблемы. Что делает указанный выше пример?
Смотрите. В схеме xmlTagList в начальном регэкспе блока записывается обобщенный
вариант таких ключевых слов, но у него смещен конец - как раз на начало
самого ключевого слова без префикса "xsl:".
Теперь, в блоке end используется очень интересный оператор - "~". Этот
оператор &laquo;привязывает&raquo; регэксп к окончанию блока start - то есть
как раз к позиции оператора \M в нем. Далее в end матчится такая же
последовательность символов слова, и только после этого ставится параметр \m,
который указывает, что начало конца блока сместится вправо - тем самым позволяя
ключевым словам в схеме xlsTags без препятствий выделиться.

<p>Ну, это один из примеров - на самом деле с этими возможностями можно
придумывать намного более сложные вещи. Смотрите к примеру схему языка Perl -
base/perl.hrc - всю вам ее понять все равно не удастся, но некоторые части
можно проанализировать. К примеру поддержку таких &laquo;строенных&raquo;
конструкций:


<pre>

 <font color=#45d002>s(</font><font color=#696969>          #</font><font color=#c4c400></font>
<font color=#c4c400>   </font><font color=#977900>$foo</font><font color=#c4c400></font>
<font color=#c4c400>   (sf)</font>

 <font color=#c4c400>  </font><font color=#45d002>)</font><font color=#696969>          # great perversion - but...</font><font color=#c4c400></font>
          <font color=#696969>#  note here could be only comments</font><font color=#c4c400></font>
 <font color=#c4c400>  </font><font color=#45d002>(</font><font color=#c4c400></font>
<font color=#c4c400></font>
<font color=#c4c400>   </font><font color=#008c00>12</font><font color=#696969>        # foo quux</font><font color=#c4c400></font>
<font color=#c4c400>   (</font><font color=#977900>$bar</font><font color=#c4c400>)</font>
<font color=#c4c400></font>
<font color=#c4c400>  </font><font color=#45d002>)ix</font><font color=#800080>;</font>

</pre>




<h3>Виртуализация и наследование</h3>
<p>
Ну вот и добрались до последнего из обязательных разделов. Здесь я расскажу
о некоторых свойствах большинства языков, которые принуждают использовать
такие механизмы, как виртуализация схем в наследовании.
<p>
Во многих языках существуют констукции, которые задают вложенность языка
самого в себя. Это такие естественные конструкции, как фигурные скобки в Си,
или блоки <code>begin/end</code> в паскале. Вообще, они как бы не нуждаются в
дополнительной обработке, но в последних версиях колорера появившиеся возможности
обработки парных констукций и поиска ошибок вынуждают писать схемы, которые
уже больше похожи на описания лексического анализатора - иными словами схемы,
которые разбирают именно структуру языка (следуя его логике).
Такая работа позволяет использовать обработку парных конструкций, поиска ошибок
в этих вложенностях, поиск функций (и вообще любых списковых структур).
<p>Все было бы хорошо, но такая работа несколько не согласуется с уже
показанным мною механизмом наследования. Предположим, схема Си++ наследует схему
Си, доопределяя ее необходимыми свойствами. Но в схеме Си содержатся структуры,
генерирующие рекурсивный же ее вызов из себя. Что тогда получится при разборе
Си++ кода? На верхнем уровне это будет Си++ схема, но как только встретится
любая структура, переводящая контекст в схему Си (те же парные скобки),
вложенная схема будет уже чистым Си!
<p>Еще один пример нелогичной работы механизма наследования. Представьте, что
у вас есть схема, которая наследует схему некоего сложного языка (состоящего из
многих схем), доопределяя некоторые ее свойства. Но очень часто при наследовании
необходимо оставить неизменными свойства самого непосредственного предка, изменив
при этом свойства некоторых схем, используемых им. Такое сделать вообще никак
не удастся.
<p>Можно представить, что традиционная схема наследования является одноуровневой.
То есть я могу использовать свойства других схем, но сами эти схемы будут для
меня черными ящиками - нельзя изменить их поведение &laquo;изнутри&raquo;.
И вот теперь, после этих примеров, я покажу как введенный в колорере механизм
виртуализации позволяет разрешить поставленные проблемы.
<p>Посмотрите на этот пример:

<pre>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;inherit </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>c</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>     </font><font color=#9391ec>&lt;virtual </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>c</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>subst</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>cpp</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;/inherit&gt;</font><font color=#ee00ee></font>
</pre>

<p>Это то самое место, где в схеме Си++ наследуется схема Си. Но наследуется она
необычно - а с использованием тэга virtual. Этот тэг и реализует механизм
виртуализации. Что он значит? Он говорит колореру, что при включении
в схему Си++ схемы Си, любые дальнейшие попытки сослаться на схему Си из нее же
будут приводить к тому, что эти ссылки заменятся на ссылки на схему Си++.
Произойдет подмена, виртуализация схемы Си на схему Си++.
Как теперь понимаете, проблема с вложенными в себя же языковыми структурами
полностью снимается. Замечу, что под понятием ссылки на схему я имею ввиду
либо переключение на нее в каком либо блоке, либо наследование ее, либо ее
же виртуализация - причем в любой схеме, вложенной по любой рекурсии в
схему Си. Естественно, блоков virtual может быть хоть сколько.

<p>На элементарном уровне, надеюсь, разобрались. Виртуализация - это всего лишь
замена одной схемы на другую везде, где она встречается.
Теперь более сложные мыслишки. Виртуализация может быть вложенной.
Ну не надо истерического смеха. На самом деле, некоторые даже смогут это понять.
Для того чтобы в это врубиться, надо представить, что каждая сложная схема
представляет (для виртуального механизма) набор своих подсхем, которые можно
виртуализовать. Если описания требуют виртуализации одной или нескольких из них,
то этот набор изменится: схемы подменятся. А на дальнейших уровнях виртуализации
вплоть до самого верхнего все будет точно так же.

<p>Еще важно сказать одно предложение.
Если есть набор уровней виртуализаций, и на каком-то из них необходима
подмена, то для подмененной схемы (на которую подменили) отключатся все
системы виртуализации низших уровней, а виртуализации более высоких порядков
останутся.

<p>Как пример покажем такую систему взаимодействия:

<pre>
<font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>mPairedBrackets</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#696969>&lt;!-- paired block --&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;block</font><font color=#ee00ee> </font><font color=#0c8164>start</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>(</font><font color=#808000>\{</font><font color=#ffae7d>)</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>end</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>(</font><font color=#808000>\}</font><font color=#ffae7d>)</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>mPairedBrackets</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>          </font><font color=#0c8164>region00</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dSymbol2</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region01</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dpOpenStruct</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>          </font><font color=#0c8164>region10</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dSymbol2</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region11</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dpCloseStruct</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;block</font><font color=#ee00ee> </font><font color=#0c8164>start</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>(</font><font color=#808000>\(</font><font color=#ffae7d>)</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>end</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>(</font><font color=#808000>\)</font><font color=#ffae7d>)</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>mPairedBrackets</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>          </font><font color=#0c8164>region00</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dSymbol</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region01</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dpOpenStruct</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>          </font><font color=#0c8164>region10</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dSymbol</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region11</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dpCloseStruct</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;block</font><font color=#ee00ee> </font><font color=#0c8164>start</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>(</font><font color=#808000>\[</font><font color=#ffae7d>)</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>end</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>(</font><font color=#808000>\]</font><font color=#ffae7d>)</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>mPairedBrackets</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>          </font><font color=#0c8164>region00</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dSymbol</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region01</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dpOpenStruct</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>          </font><font color=#0c8164>region10</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dSymbol</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region11</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>dpCloseStruct</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#9391ec>&lt;/scheme&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee></font>
<font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>C</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;inherit </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>mPairedBrackets</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>     </font><font color=#9391ec>&lt;virtual </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>mPairedBrackets</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>subst</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>c</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>   </font><font color=#9391ec>&lt;/inherit&gt;</font><font color=#ee00ee></font>
...
</pre>

<p>Схема mPairedBrackets определяет набор для расцветки и обнаружения
парных скобок всех типов. Причем в качестве вложенной схемы она использует
себя - тем самым достигается любая вложенность любых скобок.
Но посмотрите теперь на схему "C". Она наследует эту схему, но
виртуализирует ее на себя. Что получится? схема mPairedBrackets будет играть
роль скелета для схемы Си - эта схема обретет возможность матчинга парных
конструкций.

<p>Такое элементарное применение виртуального механизма можно встретить во многих
схемах. Если вам надо что-то сложнее, то попробуйте понять работу схем ASP, PHP.
Ну на крайняк xml/xsl (там проще).

<h2>Правила написания hrc</h2>
<p>
При описании синтаксиса языков программирования на hrc лучше придерживаться
некоторых устоявшихся правил, которые не являются стандартом, но несоблюдение
которых усложнит в конечном итоге жизнь и вам и другим.
<p>Первое и, может быть, основное: придерживайтесь стандарта xml.
Все тэги - в нижнем регистре (чтоб не путаться), все параметры заключены в двойные
или одинарные кавычки. Заметьте, что в отличии от описания самого hrc,
названия лексем, имен схем, типов - регистронезависимы.
<p>При определении синтаксического выделения пользуйтесь встроенными
лексемами (d.*). Вообще говоря, помимо встроенных вы ничего больше и не сможете
использовать. Но еще более важное правило - определяйте выделение элементов
текста в соответствии со смыслом этих лексем. Иными словами не надо
определять комментарии цветом чисел только потому что вам цвет их нравится.
Колорер - синтаксический парсер. Он ничего не знает на начальном этапе о
реальных цветах того или иного региона. Если вам хочется видеть цвета на свой
вкус, то создавайте свои HRD файлы, но не уродуйте оригинальные hrc.
<p>При написании своих собственных hrc старайтесь так же использовать
переопределения базовых цветовых регионов на регионы спецефические
для вашего типа файла. Все схемы, относящиеся к разбору одного типа лучше
держать в одном файле, а не разбрасывать где не попадя. Более того, старайтесь
где возможно использовать уже существующие схемы или макросы (они определены в
defines.hrc). Это обеспечит большую гибкость ваших кодов и связанность
изменений и улучшений. Так же всегда помните о возможности виртуализации
вашей схемы, и сами применяйте эти механизмы где возможно. Это обеспечит
компактность и сцепленность всей hrc-базы.


<h2>Общая структура</h2>
<p>Ну, на последок окиньте взглядом всю структуру hrc:
<pre>
<font color=#738000>&lt;?xml version="1.0" encoding="Windows-1251"?&gt;</font>
<font color=#738000>&lt;!DOCTYPE hrc SYSTEM "hrc.dtd"&gt;</font>
<font color=#738000>&lt;?xml-stylesheet type="text/xsl" href="hrc.xsl"?&gt;</font>
<font color=#9391ec>&lt;hrc ver="4ever"&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;define </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>rname</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>value</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>regid</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;include </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>fname</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>sname</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;inherit </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>sname</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>      </font><font color=#9391ec>&lt;virtual </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>sname</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>subst</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>sname</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;/inherit&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;regexp</font><font color=#ee00ee> </font><font color=#0c8164>match</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>regioni</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>rname</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>lowpriority</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>lowpriority</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;block</font><font color=#ee00ee>  </font><font color=#0c8164>start</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>end</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>scheme</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>sname</font><font color=#ffae7d>"</font><font color=#ee00ee></font>
<font color=#ee00ee>            </font><font color=#0c8164>region</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>rname</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>regionij</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>rname</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>lowpriority</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>lowpriority</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;keywords</font><font color=#ee00ee> </font><font color=#0c8164>ignorecase</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>ignorecase</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>worddiv</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>[</font><font color=#ffae7d>]</font><font color=#ffae7d>/"</font><font color=#ee00ee> </font><font color=#0c8164>region</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>rname</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>      </font><font color=#9391ec>&lt;word</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>wname</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>region</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>rname</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>      </font><font color=#9391ec>&lt;symb</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>wname</font><font color=#ffae7d>"</font><font color=#9391ec>/&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;/keywords&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;/scheme&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;type</font><font color=#ee00ee> </font><font color=#0c8164>descr</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>descr</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>tname</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>exts</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>/"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;load</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>fname</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;scheme</font><font color=#ee00ee> </font><font color=#0c8164>name</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>sname</font><font color=#ffae7d>"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>    </font><font color=#9391ec>&lt;switch</font><font color=#ee00ee> </font><font color=#0c8164>type</font><font color=#9391ec>=</font><font color=#ffae7d>"</font><font color=#c4c400>tname</font><font color=#ffae7d>"</font><font color=#ee00ee> </font><font color=#0c8164>match</font><font color=#9391ec>=</font><font color=#ffae7d>"/</font><font color=#ffae7d>/"</font><font color=#9391ec>&gt;</font><font color=#ee00ee></font>
<font color=#ee00ee>  </font><font color=#9391ec>&lt;/type&gt;</font><font color=#ee00ee></font>
<font color=#9391ec>&lt;/hrc&gt;</font>
</pre>

<div align=right><small>
Когда ты был мал, ты знал все что знал,<br>
И собаки не брали твой след...<br>
Теперь ты открыт, ты отбросил свой щит,<br>
Ты не помнишь кто прав а кто слеп...<br>
</small></div>

</body>
</html>