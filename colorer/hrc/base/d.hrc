<?xml version="1.0" encoding="Windows-1251"?>
<!DOCTYPE hrc PUBLIC "-//Cail Lomecb//DTD Colorer HRC take5//EN"
	"http://colorer.sf.net/2003/hrc.dtd">
<hrc version="take5" xmlns="http://colorer.sf.net/2003/hrc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://colorer.sf.net/2003/hrc http://colorer.sf.net/2003/hrc.xsd"
 >
	
<type name="d">
	<annotation><documentation>
		D syntax description
	</documentation><contributors><![CDATA[
		Eugene Efremov <4mirror@mail.ru>
		Vladimir Panteleev <thecybershadow@gmail.com>
	]]></contributors>
	<appinfo><todo>
		- Fix delegate outlines (how?)
		- Check phobos keywords for correctly
		- DDOC comments support
		- D 2.0 syntax support
		- Optional win32 keywords from c.hrc (it's need?)
	</todo></appinfo>
</annotation>

<region name='comment' parent='def:Comment'/>
<region name='comment.quote' parent='comment'/>

<region name='char.esc' parent='c:StringEscape'/>
<region name='char' parent='c:Character'/>
<region name='string' parent='def:String'/>
<region name='string.quote' parent='def:StringEdge'/>
<region name='string.pref' parent='regexp:SpecArea'/>
<region name='string.format' parent='def:VarStrong'/>

<region name='prefix' parent='def:NumberPrefix'/>
<region name='postfix' parent='def:NumberSuffix'/>
<region name='suffix' parent='def:NumberSuffix'/>

<region name='symb' parent='c:Symbol'/>
<region name='symb.op' parent='symb'/>
<region name='symb.struct' parent='c:StructureSymbol'/>
<region name='symb.tpl' parent='symb.struct'/>

<region name='key' parent='def:Keyword'/>
<region name='key.bool' parent='key'/>
<region name='key.type' parent='def:Keyword'/>
<region name='key.spec' parent='def:Constant'/>
<region name='key.over' parent='key'/>
<region name='key.var' parent='def:Var'/>
<region name='key.prop' parent='def:KeywordStrong'/>

<region name='key.lib.const' parent='def:Constant'/>
<region name='key.lib.type' parent='def:ClassKeyword'/>
<region name='key.lib.fun' parent='def:FunctionKeyword'/>
<region name='key.fun.main' parent='key.lib.fun'/>

<region name='decl.module' parent='def:Directive'/>
<region name='decl' parent='def:Directive'/>

<region name='label' parent='def:Label'/>
<region name='label.mark' parent='def:Label'/>
<region name='label.const' parent='def:Constant'/>

<region name='out' parent='def:Outlined'/>
<region name='module.out' parent='java:PackageOutline'/>
<region name='import.out' parent='java:ImportOutline'/>
<region name='class.out' parent='cpp:ClassOutline'/>
<region name='struct.out' parent="c:StructOutline"/>
<region name='tpl.out' parent="struct.out"/>
<region name='ifase.out' parent='class.out'/>
<region name='enum.out' parent="c:EnumOutline"/>
<region name='version.out' parent='out'/>
<region name='fun.out' parent='c:FuncOutline'/>


<entity name='id' value='\b[\w-[\d]]\w*\b'/>
<entity name='hex' value='[\dA-Fa-f]'/>

<!-- error -->

<scheme name='error'>
	<regexp match='/\S/' region='def:Error' priority='low'/>
</scheme>

<scheme name='error.strong'>
	<regexp match='/./' region='def:Error' priority='low'/>
</scheme>


<!-- comments -->

<scheme name='comment.content'>
	<inherit scheme='def:Comment'/>
</scheme>

<scheme name='comment.rec.block'>
	<block scheme='comment.rec' region='comment'>
		<start match='/(\/\+)/' region0='comment.quote' region1='def:PairStart'/>
		<end   match='/(\+\/)/' region0='comment.quote' region1='def:PairEnd'/>
	</block>
</scheme>

<scheme name='comment.rec'>
	<inherit scheme='comment.content'/>
	<inherit scheme='comment.rec.block'/>
</scheme>

<scheme name='comment'>
	<block start='/(\/\/)/' end='/$/'
		scheme='comment.content' region='comment' region00='comment.quote' 
	/>
	<block scheme='comment.content' region='comment'>
		<start match='/(\/\*)/' region0='comment.quote' region1='def:PairStart'/>
		<end   match='/(\*\/)/' region0='comment.quote' region1='def:PairEnd'/>
	</block>
	<inherit scheme='comment.rec.block'/>
</scheme>



<!-- char/string -->
<entity name='str.post' value='(?{postfix}[cwd]?)'/>

<scheme name='char.entity'>
	<inherit scheme='html-entity:html-addref'/>
	<inherit scheme='error.strong'/>
</scheme>

<scheme name='char.quote'>
	<block start='/(\\)&amp;\M\w+;/' end='/~\w+\m;/' 
		scheme='char.entity' region='xml:CharRef' 
		region01='char.esc'
	/>
	<regexp match='/\\[&apos;&quot;?\\abfnrtv]/' region='char.esc'/>
	<regexp match='/\\x%hex;{2}/' region='char.esc'/>
	<regexp match='/\\u%hex;{4}/' region='char.esc'/>
	<regexp match='/\\U%hex;{8}/' region='char.esc'/>
	<regexp match='/\\o[0-7]{1,3}/' region='char.esc'/>
</scheme>

<scheme name='char.content'>
	<inherit scheme='char.quote'/>
	<inherit scheme='error.strong'/>
</scheme>

<scheme name='char'>
	<regexp match="/(')([^'\\])(')/" region='string.quote'
		region1='def:PairStart' region2='string' region3='def:PairEnd'
	/>
	<block scheme='char.content' region='string'>
		<start match="/(')\M\\/" region0='string.quote' region1='def:PairStart'/>
		<end   match="/(')/"     region0='string.quote' region1='def:PairEnd'/>
	</block>
	<inherit scheme='char.quote'/>
</scheme>

<scheme name='string.format' if='format-str'>
	<regexp match='/\%{2}/' region='char.esc'/>
	<regexp match='/\%[\-+#0 ]?(\d+|\*)?(\.(\d+|\*)?)?[sbdoxXeEfFgGaA]/' region='string.format'/>
</scheme>

<scheme name='string.content'>
	<inherit scheme='char.quote'/>
	<inherit scheme='string.format'/>
</scheme>

<scheme name='string.hex'>
	<regexp match='/%hex;/' region='char.esc'/>
	<inherit scheme='error'/>
</scheme>

<scheme name='string.all'>
	<block scheme='def:empty' region='string'>
		<start match='/(r)(")/' 
			region0='string.quote' region1='string.pref' region2='def:PairStart'
		/>
		<end match='/(")%str.post;/' region0='string.quote' region1='def:PairEnd'/>
	</block>
	<block scheme='def:empty' region='string'>
		<start match='/(`)/' region0='string.quote' region1='def:PairStart'/>
		<end   match='/(`)%str.post;/' region0='string.quote' region1='def:PairEnd'/>
	</block>
	
	<block scheme='string.hex' region='string'>
		<start match='/(x)(")/' 
			region0='string.quote' region1='string.pref' region2='def:PairStart'
		/>
		<end match='/(")%str.post;/' region0='string.quote' region1='def:PairEnd'/>
	</block>
	
	<block scheme='string.content' region='string'>
		<start match='/(")/' region0='string.quote' region1='def:PairStart'/>
		<end match='/(")%str.post;/' region0='string.quote' region1='def:PairEnd'/>
	</block>
</scheme>


<scheme name='string'>
	<inherit scheme='char'/>
	<inherit scheme='string.all'/>
</scheme>


<!-- literal -->

<entity name='int.post' value='(?{postfix}[LUlu]{0,2})'/>
<entity name='float.post' value='(?{postfix}[fFL]i|[fFL]|i)'/>

<entity name='hexd' value='[\dA-Fa-f_]'/>

<scheme name='literal.int'>
	<regexp match='/\b0%int.post;\b/' region='def:NumberDec'/>
	<regexp match='/\b[1-9][\d_]*%int.post;\b/' region='def:NumberDec'/>
	<regexp match='/\b(0)[1-70_]+%int.post;\b/' region='def:NumberOct' region1='prefix'/>
	<regexp match='/\b0(b)[10_]+%int.post;\b/i' region='def:NumberBin' region1='prefix'/>
	<regexp match='/\b0(x)%hexd;+%int.post;\b/i' region='def:NumberHex' region1='prefix'/>
</scheme>

<entity name='float.exp' value='(?{}(?{suffix}[eE][\-+]?)\d[\d_]*)'/>
<entity name='float.exh' value='(?{}(?{suffix}[pP][\-+]?)\d[\d_]*)'/>

<scheme name='literal.float'>
	<regexp 
		match='/(\b\d[\d_]*\.[\d_]*|\.\d+)%float.exp;?%float.post;?\b/'
		region0='def:NumberFloat'
	/>
	<regexp 
		match='/\b0(x)(%hexd;+*\.%hexd;*|\.%hexd;+)%float.exh;?%float.post;?\b/i'
		region0='def:NumberFloat' region1='prefix'
	/>
	
	<regexp match='/\b([1-9][\d_]*|0_*)(%float.exp;|%float.post;|%float.exp;%float.post;)\b/i'
		region0='def:NumberFloat'
	/>
	<regexp match='/\b0(x)(%hexd;+)(%float.exh;|%float.post;|%float.exh;%float.post;)\b/i'
		region0='def:NumberFloat' region1='prefix'
	/>
	
	<!--
	<regexp 
		match='/\w?~1(\d[\d_]*(\.[\d_]*)?|\.\d[\d_]*)([eE][\+\-]?)\d[\d_]*%float.post;\b/'
		region0='def:NumberFloat' region3='suffix'
	/>
	<regexp 
		match='/\w?~1(\d[\d_]*\.[\d_]*|\.\d[\d_]*)%float.post;\w?!/'
		region0='def:NumberFloat' 
	/>
	
	<regexp 
		match='/\b0([xX])[\dA-Fa-f_]*(\.[\dA-Fa-f_]*)?([pP][\+\-]?)\d[\d_]*%float.post;\b/'
		region0='def:NumberFloat' region1='prefix' region3='suffix'
	/>-->
</scheme>

<scheme name='literal.bool'>
	<keywords region='key.bool'>
		<word name='true'/>
		<word name='false'/>
		<word name='null'/>
	</keywords>
</scheme>

<scheme name='literal'>
	<inherit scheme='literal.float'/>
	<inherit scheme='literal.int'/>
	<inherit scheme='literal.bool'/>
	<regexp match='/\b\d+/' region='def:Error'/>
</scheme>


<scheme name='op'>
	<block scheme='d.expr'>
		<start match='/(\?)/' 
			region0='symb.struct' region1='def:PairStart'
		/>
		<end match='/(\:)/' 
			region0='symb.struct' region1='def:PairEnd'
		/>
	</block>
	
	
	<keywords region='symb.op'>
		<symb name='/'/>
		<symb name='/='/>
		<symb name='.'/>
		<symb name='..'/>
		<symb name='...'/>
		<symb name='&amp;'/>
		<symb name='&amp;='/>
		<symb name='&amp;&amp;'/>
		<symb name='|'/>
		<symb name='|='/>
		<symb name='||'/>
		<symb name='-'/>
		<symb name='-='/>
		<symb name='--'/>
		<symb name='+'/>
		<symb name='+='/>
		<symb name='++'/>
		<symb name='&lt;'/>
		<symb name='&lt;='/>
		<symb name='&lt;&lt;'/>
		<symb name='&lt;&lt;='/>
		<symb name='&lt;>'/>
		<symb name='&lt;>='/>
		<symb name='>'/>
		<symb name='>='/>
		<symb name='>>='/>
		<symb name='>>>='/>
		<symb name='>>'/>
		<symb name='>>>'/>
		<symb name='!'/> <!-- ?? not work -->
		<symb name='!='/>
		<symb name='!=='/>
		<symb name='!&lt;>'/>
		<symb name='!&lt;>='/>
		<symb name='!&lt;'/>
		<symb name='!&lt;='/>
		<symb name='!>'/>
		<symb name='!>='/>
		<symb name='!~'/>
		<symb name='$' region='def:Var'/>
		<symb name='='/>
		<symb name='=='/>
		<symb name='==='/>
		<symb name='*'/>
		<symb name='*='/>
		<symb name='%'/>
		<symb name='%='/>
		<symb name='^'/>
		<symb name='^='/>
		<symb name='~'/>
		<symb name='~='/>
		<symb name='~~'/>
		<word name='is'/>
	</keywords>
	<regexp match='/\!/' region='symb.op'/>
</scheme>

<!-- types -->

<scheme name='type.arr'>
	<inherit scheme='literal.int'/>
	<inherit scheme='type'/>
</scheme>

<scheme name='type'>
	<keywords region='key.type'>
		<word name='void'/>
		<word name='bit'/>
		<word name='bool'/>
		<word name='byte'/>
		<word name='ubyte'/>
		<word name='short'/>
		<word name='ushort'/>
		<word name='int'/>
		<word name='uint'/>
		<word name='long'/>
		<word name='ulong'/>
		<word name='cent'/>
		<word name='ucent'/>
		<word name='float'/>
		<word name='double'/>
		<word name='real'/>
		<word name='ifloat'/>
		<word name='idouble'/>
		<word name='ireal'/>
		<word name='cfloat'/>
		<word name='cdouble'/>
		<word name='creal'/>
		<word name='char'/>
		<word name='wchar'/>
		<word name='dchar'/>
		
		<word name='size_t'/>
		
		<word name='auto'/>
		<word name='alias'/>
		
		<!-- type class -->
	</keywords>
	
	<keywords region='symb'>
		<symb name='*'/>
	</keywords>
	<block scheme='type.arr'>
		<start match='/(\[)/' 
			region0='symb' region1='def:PairStart'
		/>
		<end match='/(\])/' 
			region0='symb' region1='def:PairEnd'
		/>
	</block>
	<block scheme='d.expr'>
		<start match='/\b(function|delegate|typeof)\s*((\())/' 
			region1='key' region2='symb' region3='def:PairStart'
		/>
		<end match='/((\)))/' 
			region1='symb' region2='def:PairEnd'
		/>
	</block>
	
	<keywords region='key.type'>
		<word name='typedef'/>
		<word name='struct'/>
		<word name='union'/>
		<word name='class'/>
		<word name='interface'/>
		<word name='enum'/>
		<word name='function'/>
		<word name='delegate'/>
		<word name='return'/>
	</keywords>
</scheme>


<!-- module -->

<scheme name='module.content'>
	<regexp match='/%id;(\.)\M%id;/' region='decl.module' region1='symb'/>
	<regexp match='/%id;/' region='decl.module'/>
	<inherit scheme='comment'/>
	<inherit scheme='error'/>
</scheme>

<scheme name='module'>
	<block start='/^\s*module\M\s+([\w\.]*)/' end='/;/' scheme='module.content'
		region00='key' region10='symb.struct' region01='module.out'
	/>
</scheme>



<!-- templates -->


<scheme name='tpl'>
	<block scheme='type'>
		<start match='/\bcast\s*((\())/' 
			region0='key' region1='symb.struct' region2='def:PairStart'
		/>
		<end match='/(\))/' 
			region0='symb.struct' region1='def:PairEnd'
		/>
	</block>
	
	<inherit scheme='tpl.tpl'/>
</scheme>


<scheme name='tpl.fun.proxy'>
	<block scheme='decl.class.tpl'>
		<start match='/(\()/' region0='symb.tpl' region1='def:PairStart' />
		<end match='/(\))/'    region0='symb.tpl' region1='def:PairEnd'   />
	</block>
	<inherit scheme='keys'/>
</scheme>

<scheme name='tpl.tpl.proxy'>
	<block scheme='d.expr'>
		<start match='/(!\()/' region0='symb.tpl' region1='def:PairStart' />
		<end match='/(\))/'    region0='symb.tpl' region1='def:PairEnd'   />
	</block>
	<inherit scheme='keys'/>
</scheme>

<scheme name='tpl.tpl'>
	<block scheme='tpl.tpl.proxy' start='/\M%id;\s*!\(/' end='/\)?#1/' />
</scheme>



<!-- declares -->
<!-- decl.import -->

<scheme name='decl.import.content'>
	<keywords region='symb'>
		<symb name=','/>
		<symb name='='/>
		<symb name=':'/>
	</keywords>
	<inherit scheme='module.content'/>
</scheme>

<scheme name='decl.import'>
	<block start='/\bimport\M\s+([\w\.\s\,\:\=]*)/' end='/;/' scheme='decl.import.content'
		region00='key' region10='symb.struct' region01='import.out'
	/>
</scheme>


<!-- decl.attr -->

<scheme name='decl.attr.extern'>
	<keywords region='decl'>
		<symb name='C++'/>
		<word name='C'/>
		<word name='D'/>
		<word name='Windows'/>
		<word name='Pascal'/>
	</keywords>
	<inherit scheme='error'/>
</scheme>

<scheme name='decl.attr.align'>
	<inherit scheme='literal.int'/>
	<inherit scheme='error'/>
</scheme>

<scheme name='decl.attr.pragma'>
	<regexp match='/~\s*(msg|lib)/' region='decl'/>
	<inherit scheme='d.expr'/> <!-- !!!!!!!!!!!! -->
</scheme>

<scheme name='decl.attr.vd'>
	<regexp match='/%id;/' region='decl'/>
	<inherit scheme='decl.attr.align'/>
</scheme>


<scheme name='decl.attr'>
	
	<!-- extern -->
	<block scheme='decl.attr.extern'>
		<start match='/\bextern\s*((\())/' 
			region0='key' region1='symb' region2='def:PairStart'
		/>
		<end match='/((\)))\s*:?/' 
			region0='label.mark' region1='symb' region2='def:PairEnd'
		/>
	</block>
	
	<!-- align -->
	<block scheme='decl.attr.align'>
		<start match='/\balign\s*((\())/' 
			region0='key' region1='symb' region2='def:PairStart'
		/>
		<end match='/((\)))\s*:?/' 
			region0='label.mark' region1='symb' region2='def:PairEnd'
		/>
	</block>
	
	<!-- version -->
	<block scheme='decl.attr.vd'><!-- \M(\s*\w+ -->
		<start match='/\bversion\s*((\())\M(\s*\w+)/' 
			region0='key' region1='symb' region2='def:PairStart' region3='version.out'
		/>
		<end match='/((\)))\s*:?/' 
			region0='label.mark' region1='symb' region2='def:PairEnd'
		/>
	</block>
	
	<!-- pragma -->
	<block scheme='decl.attr.pragma'>
		<start match='/\bpargma\s*((\())/' 
			region0='key' region1='symb' region2='def:PairStart'
		/>
		<end match='/((\)))\s*:?/' 
			region0='label.mark' region1='symb' region2='def:PairEnd'
		/>
	</block>
	
	<!-- debug -->
	<block scheme='decl.attr.vd'>
		<start match='/\b(debug)\s*((\())/' 
			region1='key' region2='symb' region3='def:PairStart' 
		/>
		<end match='/((\)))\s*:?/' 
			region0='label.mark' region1='symb' region2='def:PairEnd'
		/>
	</block>
	
	
	<regexp region1='key' region2='label.mark'>
		/\b( extern
			| align 
			| deprecated
			| private
			| package
			| protected
			| public
			| export
			| static
			| final
			| override
			| abstract
			| const
			| auto
			| debug
		)\b\s*(:)?/x</regexp>
</scheme>


<!-- decl.class -->

<scheme name='decl.class.decl'>
	<block scheme='decl.class.tpl'>
		<start match='/(\()/' region0='def:PairStart' region1='symb.tpl'/>
		<end match='/(\))/' region0='def:PairEnd' region1='symb.tpl'/>
	</block>
	<inherit scheme='comment'/>
	<inherit scheme='keys'/>
	<!--regexp match='/\S/' region='def:Error' priority='low'/-->
</scheme>


<scheme name='decl.class.tpl'>
	<inherit scheme='type'/>
	<inherit scheme='literal'/>
	<keywords region='symb'>
		<symb name=','/>
		<symb name=':' region='symb.struct'/>
		<symb name='='/>
		<symb name='...'/>
	</keywords>
	<inherit scheme='tpl.tpl'/>
	<inherit scheme='comment'/>
	<inherit scheme='keys'/>
</scheme>

<scheme name='decl.class'>
	<!-- Heuristics template/outline search  -->
	<block scheme='decl.class.decl'><!-- (\s*\(.+?\))? -->
		<start match='/\b(class)\s+\M(%id;(\s*\(.+?(\)|$))?)/' 
			region1='key' region2='class.out'
		/>
		<end match='/(:)|\{?=/' region1='symb.struct'/>
	</block>
	<block scheme='decl.class.decl'>
		<start match='/\b(struct|union)\s+\M(%id;(\s*\(.+?(\)|$))?)/' 
			region1='key' region2='struct.out'
		/>
		<end match='/\{?=/'/>
	</block>
	<block scheme='decl.class.decl'>
		<start match='/\b(template)\s+\M(%id;\s*\(.+?(\)|$))/' 
			region1='key' region2='tpl.out'
		/>
		<end match='/\{?=/'/>
	</block>
	<block scheme='def:empty'> <!-- no tempaltes -->
		<start match='/\b(enum)\b\M(\s+%id;)?/' 
			region1='key' region2='enum.out'
		/>
		<end match='/(:)|\{?=/' region1='symb.struct'/>
	</block>
	<block scheme='def:empty'> <!-- no tempaltes ?? -->
		<start match='/\b(interface)\b\s+\M(%id;)/' 
			region1='key' region2='ifase.out'
		/>
		<end match='/(:)|\{?=/' region1='symb.struct'/>
	</block>
	
	
	<!-- sometimes heuristics fail :-( -->
	<keywords region='key'>
		<word name='class'/>
		<word name='struct'/>
		<word name='union'/>
		<word name='template'/>
		<word name='emun'/>
		<word name='interface'/>
	</keywords>
	
</scheme>


<!-- decl.cong --> 

<scheme name='decl.cong'>
	<keywords region='key'>
		<word name='invariant'/>
		<word name='unittest'/>
	</keywords>
</scheme>



<!-- decl.constr -->

<scheme name='decl.constr'>
	<block scheme='d.expr'>
		<start match='/(\w?~1(\~?this|new|delete)\s*((\())\M.+?(\)|$))[^;]*$/' 
			region1='fun.out'
			region2='key' region3='symb' region4='def:PairStart'
		/>
		<end match='/(\))/' 
			region0='symb' region1='def:PairEnd'
		/>
	</block>
	<keywords region='key'>
		<word name='this'/>
		<word name='super'/>
		<word name='new'/>
		<word name='delete'/>
	</keywords>
	
	
</scheme> 

<scheme name='decl.fun'>
	<!-- bug: with delegates it's work incorrect -->
	<regexp match='/\M(?{fun.out}(\bout\b)?!%id;(\s*\([^\);]*?\)){1,2})[^;]*($|\{)/'/>
	
	<block scheme='tpl.fun.proxy'>
		<start match='/\M%id;\s*\([^\(\);]*?\)\s*\([^\);]*?\)[^;]*($|\{)/'/>
		<end match='/\)?#1/'/>
	</block>   
	
	<keywords region='key.over'>
		<word name='opNeg'/>
		<word name='opPos'/>
		<word name='opCom'/>
		<word name='opPostInc'/>
		<word name='opPostDec'/>
		<word name='opCast'/>
		<word name='opAdd'/>
		<word name='opAdd_r'/>
		<word name='opSub'/>
		<word name='opSub_r'/>
		<word name='opMul'/>
		<word name='opMul_r'/>
		<word name='opDiv'/>
		<word name='opDiv_r'/>
		<word name='opMod'/>
		<word name='opMod_r'/>
		<word name='opAnd'/>
		<word name='opAnd_r'/>
		<word name='opOr'/>
		<word name='opOr_r'/>
		<word name='opXor'/>
		<word name='opXor_r'/>
		<word name='opShl'/>
		<word name='opShl_r'/>
		<word name='opShr'/>
		<word name='opShr_r'/>
		<word name='opUShr'/>
		<word name='opUShr_r'/>
		<word name='opCat'/>
		<word name='opCat_r'/>
		<word name='opEquals'/>
		<word name='opCmp'/>
		<word name='opAssign'/>
		<word name='opAddAssign'/>
		<word name='opSubAssign'/>
		<word name='opMulAssign'/>
		<word name='opDivAssign'/>
		<word name='opModAssign'/>
		<word name='opAndAssign'/>
		<word name='opOrAssign'/>
		<word name='opXorAssign'/>
		<word name='opShlAssign'/>
		<word name='opShrAssign'/>
		<word name='opUShrAssign'/>
		<word name='opCatAssign'/>
		<word name='opIn'/>
		<word name='opIn_r'/>
		<word name='opIndex'/>
		<word name='opIndexAssign'/>
		<word name='opApply'/>
		<word name='opApplyReverse'/>
		<word name='opCall'/>
		<word name='opSlice'/>
		<word name='opSliceAssign'/>
	</keywords>
	
	<!-- from Vladimir Panteleev's d.hrc -->
	<keywords region='key.fun.main'>
		<word name="main"/>
		<word name="WinMain"/>
		<word name="DllMain"/>
	</keywords>
</scheme> 




<!-- statemen -->

<scheme name='asmcode'>
	<regexp match='/[\{;]/' region='symb.struct'/>
	<inherit scheme='comment'/>
	<inherit scheme="asm:baseasm"/>
</scheme>


<scheme name='d.statement'>
	<block scheme='d.expr'>
		<start match='/\b(for|foreach(_reverse)?|if|while|with|switch|catch|synchronized|assert|type(id|of)|sizeof)\s*((\())/' 
			region1='key' region4='symb' region5='def:PairStart'
		/>
		<end match='/(\))/' 
			region0='symb' region1='def:PairEnd'
		/>
	</block>
	<regexp match="/\b(scope)(\()\s*(exit|success|failure)\s*(\))/"
		region0='symb' region1='key' region3='decl'
		region2='def:PairStart' region4='def:PairEnd'
	/>
	
	<block start="/\b(asm)\s*?(\{|$)/" end="/(\})/" scheme="asmcode"
		region01="key" region02="symb.struct" region10="symb.struct" 
		region00="def:PairStart" region11="def:PairEnd"
	/>
	
<!--
	<block start='/\basm\b/' end='/\}?#1/' scheme='asm.content' region00='key' />
-->	
	<block scheme='d.expr' region='label.const'>
		<start match='/\b(case|default)\b/' 
			region1='key' region2='symb' region3='def:PairStart'
		/>
		<end match='/:/' region0='label.mark'/>
	</block>
	
	<regexp match='/\b(goto(\s+(case|default))?!|continue|break)\s+(%id;)/' 
		region1='key' region4='label'
	/>
	
	<keywords region='key'>
		<word name='body'/>
		<word name='break'/>
		<word name='case'/>
		<word name='continue'/>
		<word name='default'/>
		<word name='do'/>
		<word name='else'/>
		<word name='finally'/>
		<word name='for'/>
		<word name='foreach'/>
		<word name='foreach_reverse'/>
		<word name='goto'/>
		<word name='if'/>
		<word name='mixin'/>
		<word name='override'/>
		<word name='return'/>
		<word name='synchronized'/>
		<word name='throw'/>
		<word name='try'/>
		<word name='typedef'/>
	</keywords>
	
	
	<regexp match='/%id;\s*(:)/' region0='label' region1='label.mark'/>
</scheme>


<scheme name='d.decldef'>
	<inherit scheme='decl.import'/>
	<inherit scheme='decl.attr'/>
	<inherit scheme='decl.class'/>
	<inherit scheme='decl.cong'/>
	<inherit scheme='decl.constr'/>
	<inherit scheme='d.statement'/>
	<!--inherit scheme='tpl'/-->
	<inherit scheme='tpl'/>
	<inherit scheme='decl.fun'/>
	
	
	<!--
	
	block scheme='d.decldef'>
		<start match='/(\{)/' region0='def:PairStart' region1='symb.struct'/>
		<start match='/(\})/' region0='def:PairEnd' region1='symb.struct'/>
	</block-->
	<inherit scheme="def:PairedBrackets">
		<virtual scheme="def:PairedBrackets" subst-scheme="d.decldef"/>
	</inherit>
	
	<inherit scheme='d.expr'/>
</scheme>
<scheme name='d.expr'>

	<inherit scheme="def:PairedBrackets">
		<virtual scheme="def:PairedBrackets" subst-scheme="d.expr"/>
	</inherit>

	<inherit scheme='comment'/>
	<inherit scheme='string'/>
	<inherit scheme='literal'/>
	<regexp match='/;/' region='symb.struct'/>
	<regexp match='/,/' region='symb'/>
	<inherit scheme='op'/>
	<inherit scheme='tpl'/>
	<inherit scheme='type'/>
	<keywords region='key'>
		<word name='static'/>
		<word name='auto'/>
		<word name='volatile'/>
		<word name='in'/>
		<word name='out'/>
		<word name='inout'/>
		<word name='lazy'/>
		<word name='mixin'/>
		<word name='scope'/>
		
		<!--word name='sizeof'/-->
		<word name='typeid'/>
		<word name='typeof'/>
	</keywords>
	<inherit scheme='keys.custom'/>
	
	
	<inherit scheme='tokens.spec'/>
	<inherit scheme='tokens.bad'/>
</scheme>

<!-- special tokens -->

<scheme name='tokens.spec.pre'>
	<inherit scheme='comment'/>
	<inherit scheme='c:PreprocLine'/>
	<inherit scheme='error'/>
</scheme>

<scheme name='tokens.spec'>
	<keywords region='key.spec'>
		<word name='__FILE__'/>
		<word name='__LINE__'/>
		<word name='__DATE__'/>
		<word name='__TIME__'/>
		<word name='__TIMESTAMP__'/>
		<word name='__VENDOR__'/>
		<word name='__VERSION__'/>
	</keywords>
	<block start="/#/" end='/$/'  scheme='tokens.spec.pre' region='c:Preproc'/>
</scheme>


<scheme name='tokens.bad'>
	<keywords region='def:Error'>
		<symb name='{'/>
		<symb name='}'/>
		<symb name='('/>
		<symb name=')'/>
		<symb name='['/>
		<symb name=']'/>
		<symb name='"'/>
		<symb name="'"/>
		<symb name='`'/>
	</keywords>
</scheme>

<!-- d 


<scheme name='d.all'>
	<inherit scheme='d.declare'/>
	
	<inherit scheme="def:PairedBrackets">
		<virtual scheme="def:PairedBrackets" subst-scheme="d.all"/>
	</inherit>
	<inherit scheme='keys'/>
</scheme>-->

<scheme name="d.lang">
	<inherit scheme='comment'/>
	<inherit scheme='module'/>
	<inherit scheme='d.decldef'/>
</scheme>

<scheme name='d'>
	<inherit scheme='def:unixCommentFirstline'>
		<virtual scheme="def:def" subst-scheme="d.lang"/>
	</inherit>
</scheme>



<scheme name='d.property'>
	<!--regexp region='key.prop' region1='symb'>
		/(.)\s*(alignof
			| dig
			| dup
			| epsilon
			| idup
			| im
			| infinity
			| init
			| length
			| mangleof
			| mant_dig
			| max
			| max_10_exp
			| max_exp
			| min
			| min_10_exp
			| min_exp
			| nan
			| ptr
			| re
			| reverse
			| sizeof
			| sort
			| stringof
		)\b/x
	</regexp-->
	<keywords region='key.var'>
		<word name='_argptr'/>
		<word name='_arguments'/>
	</keywords>
	
	<keywords region='key.prop'>
		<word name='alignof'/>
		<word name='dig'/>
		<word name='dup'/>
		<word name='epsilon'/>
		<word name='idup'/>
		<word name='im'/>
		<word name='infinity'/>
		<word name='init'/>
		<word name='length'/>
		<word name='mangleof'/>
		<word name='mant_dig'/>
		<word name='max'/>
		<word name='max_10_exp'/>
		<word name='max_exp'/>
		<word name='min'/>
		<word name='min_10_exp'/>
		<word name='min_exp'/>
		<word name='nan'/>
		<word name='ptr'/>
		<word name='re'/>
		<word name='reverse'/>
		<word name='sizeof'/>
		<word name='sort'/>
		<word name='stringof'/>
	</keywords>
</scheme>


<scheme name='keys.custom'>
	<inherit scheme='d.property'/>
	<keywords region='key.lib.fun'>
		<word name='print'/>
		<word name='toString'/>
		<word name='toHash'/>
		<word name='factory'/>
	</keywords>
	
	<keywords region='key.lib.type'>
		<word name='Object'/>
		<word name='Interface'/>
		<word name='ClassInfo'/>
		<word name='TypeInfo'/>
		<word name='OffsetTypeInfo'/>
		<word name='Exception'/>
		<word name='Error'/>
		<word name='size_t'/>
		<word name='ptrdiff_t'/>
		<word name='bit'/>
	</keywords>
	<inherit scheme='key.phobos'/>
</scheme>


<scheme name='key.phobos' if='use_phobos'>
	<keywords region='key.lib.const'>
		<word name='BAD_FILE_READ'/>
		<word name='BUFSIZ'/>
		<word name='BigEndian'/>
		<word name='CANNOT_OPEN_JAR_FILE'/>
		<word name='D_major'/>
		<word name='D_minor'/>
		<word name='DigitalMars'/>
		<word name='E'/>
		<word name='ELIDE_BLANK_RECORDS'/>
		<word name='EOF'/>
		<word name='EXIT_SUCCESS'/>
		<word name='FILENAME_MAX'/>
		<word name='FOPEN_MAX'/>
		<word name='FP_FAST_FMA'/>
		<word name='FP_FAST_FMAF'/>
		<word name='FP_FAST_FMAL'/>
		<word name='FP_ILOGB0'/>
		<word name='FP_ILOGBNAN'/>
		<word name='FP_INFINITE'/>
		<word name='FP_NAN'/>
		<word name='FP_NORMAL'/>
		<word name='FP_SUBNORMAL'/>
		<word name='FP_ZERO'/>
		<word name='HUGE_VAL'/>
		<word name='INFINITY'/>
		<word name='INVALID_CONTENT'/>
		<word name='INVALID_INDEX'/>
		<word name='LC_ALL'/>
		<word name='LC_COLLATE'/>
		<word name='LC_CTYPE'/>
		<word name='LC_MONETARY'/>
		<word name='LC_NUMERIC'/>
		<word name='LC_TIME'/>
		<word name='LN10'/>
		<word name='LN2'/>
		<word name='LOG10E'/>
		<word name='LOG2'/>
		<word name='LOG2E'/>
		<word name='LOG2T'/>
		<word name='LittleEndian'/>
		<word name='MATH_ERREXCEPT'/>
		<word name='MATH_ERRNO'/>
		<word name='M_1_PI'/>
		<word name='M_2_PI'/>
		<word name='M_2_SQRTPI'/>
		<word name='NAN'/>
		<word name='NO_RECORDS'/>
		<word name='ORDER_FIELDS'/>
		<word name='OUT_OF_MEMORY'/>
		<word name='PARSE_ERROR'/>
		<word name='PI'/>
		<word name='PI_2'/>
		<word name='PI_4'/>
		<word name='RECORD_SEPARATOR_IN_CONTINUATION'/>
		<word name='SQRT1_2'/>
		<word name='SQRT2'/>
		<word name='SUCCESS'/>
		<word name='SYS_OPEN'/>
		<word name='TMP_MAX'/>
		<word name='UNEXPECTED'/>
		<word name='UNFINISHED_FIELD'/>
		<word name='UNFINISHED_LINE'/>
		<word name='UNFINISHED_RECORD'/>
		<word name='WEOF'/>
		<word name='_NFILE'/>
		<word name='_SYS_OPEN'/>
		<!--symb name='altsep'/>
		<word name='curdir'/>
		<word name='d_time_nan'/>
		<word name='email'/>
		<word name='endian'/>
		<word name='linesep'/>
		<word name='math_errhandling'/>
		<word name='name'/>
		<word name='pardir'/>
		<word name='pathsep'/>
		<word name='url'/>
		<word name='sep'/-->
		<word name='stdaux'/>
		<word name='stderr'/>
		<word name='stdin'/>
		<word name='stdout'/>
		<word name='stdprn'/>
		<word name='vendor'/>
		<word name='version_major'/>
		<word name='version_minor'/>
	</keywords>
	<keywords region='key.lib.type'>
		<word name='Address'/>
		<word name='AddressException'/>
		<word name='ArchiveMember'/>
		<word name='Base64CharException'/>
		<word name='Base64Exception'/>
		<word name='BitArray'/>
		<word name='Box'/>
		<word name='BufferedFile'/>
		<word name='BufferedStream'/>
		<word name='CFile'/>
		<word name='Compress'/>
		<word name='ConvError'/>
		<word name='ConvOverflowError'/>
		<word name='Database'/>
		<word name='DatabaseException'/>
		<word name='Date'/>
		<word name='DirEntry'/>
		<word name='DynArg'/>
		<word name='Endian'/>
		<word name='EndianStream'/>
		<word name='FILE'/>
		<word name='Field'/>
		<word name='File'/>
		<word name='FileException'/>
		<word name='FilterStream'/>
		<word name='FormatError'/>
		<word name='HostException'/>
		<word name='InternetAddress'/>
		<word name='InternetHost'/>
		<word name='InvalidKeyException'/>
		<word name='InvalidTypeException'/>
		<word name='MD5_CTX'/>
		<word name='MmFile'/>
		<word name='ORJRC'/>
		<word name='ORJ_FLAG'/>
		<word name='ORJ_PARSE_ERROR'/>
		<word name='OpenException'/>
		<word name='OpenRJException'/>
		<word name='OutBuffer'/>
		<word name='OutOfMemoryException'/>
		<word name='Protocol'/>
		<word name='ReadException'/>
		<word name='Record'/>
		<word name='RegExp'/>
		<word name='RegExpException'/>
		<word name='SeekException'/>
		<word name='Service'/>
		<word name='SliceStream'/>
		<word name='Socket'/>
		<word name='SocketAcceptException'/>
		<word name='SocketException'/>
		<word name='SocketSet'/>
		<word name='SocketStream'/>
		<word name='StdioException'/>
		<word name='Stream'/>
		<word name='StreamException'/>
		<word name='StreamFileException'/>
		<word name='StringException'/>
		<word name='TcpSocket'/>
		<word name='Thread'/>
		<word name='ThreadError'/>
		<word name='Tuple'/>
		<word name='TypeClass'/>
		<word name='UdpSocket'/>
		<word name='UnCompress'/>
		<word name='UnboxException'/>
		<word name='UnknownAddress'/>
		<word name='UtfException'/>
		<word name='Vendor'/>
		<word name='WriteException'/>
		<word name='ZipArchive'/>
		<word name='ZipException'/>
		<word name='ZlibException'/>
		<word name='d_time'/>
		<word name='div_t'/>
		<word name='double_t'/>
		<word name='fcmp'/>
		<word name='fenv_t'/>
		<word name='float_t'/>
		<word name='fpos_t'/>
		<word name='lconv'/>
		<word name='ldiv_t'/>
		<word name='linger'/>
		<word name='lldiv_t'/>
		<word name='slot_t'/>
		<word name='thread_hdl'/>
		<word name='timeval'/>
		<word name='va_list'/>
	</keywords>
	<keywords region='key.lib.fun'>
		<word name='BaseTypeTuple'/>
		<word name='BoundFunc'/>
		<word name='DerivedToFront'/>
		<word name='Erase'/>
		<word name='EraseAll'/>
		<word name='FieldTypeTuple'/>
		<word name='Format'/>
		<word name='IndexOf'/>
		<word name='MemoryStream'/>
		<word name='MmFileStream'/>
		<word name='MostDerived'/>
		<word name='NoDuplicates'/>
		<word name='ParameterTypeTuple'/>
		<word name='ParseInteger'/>
		<word name='ParseUinteger'/>
		<word name='Replace'/>
		<word name='ReplaceAll'/>
		<word name='ReturnType'/>
		<word name='Reverse'/>
		<word name='Signal'/>
		<word name='TArrayStream'/>
		<word name='ToString'/>
		<word name='Tuple'/>
		<word name='TypeTuple'/>
		<word name='_fgetchar'/>
		<word name='_fputchar'/>
		<word name='_fsopen'/>
		<word name='_wtmpnam'/>
		<word name='abs'/>
		<word name='acos'/>
		<word name='acosh'/>
		<word name='addExt'/>
		<word name='addRange'/>
		<word name='addRoot'/>
		<word name='alignSize'/>
		<word name='alloca'/>
		<word name='amd'/>
		<word name='amd3dnow'/>
		<word name='amd3dnowExt'/>
		<word name='amd64'/>
		<word name='amdMmx'/>
		<word name='asin'/>
		<word name='asinh'/>
		<word name='atan'/>
		<word name='atan2'/>
		<word name='atanh'/>
		<word name='atexit'/>
		<word name='atof'/>
		<word name='bsearch'/>
		<word name='bsf'/>
		<word name='bsr'/>
		<word name='bswap'/>
		<word name='bt'/>
		<word name='btc'/>
		<word name='btr'/>
		<word name='bts'/>
		<word name='calloc'/>
		<word name='capacity'/>
		<word name='cbrt'/>
		<word name='ceil'/>
		<word name='clearerr'/>
		<word name='conj'/>
		<word name='connect'/>
		<word name='copysign'/>
		<word name='coresPerCPU'/>
		<word name='cos'/>
		<word name='cosh'/>
		<word name='decode'/>
		<word name='decodeComponent'/>
		<word name='defaultExt'/>
		<word name='demangle'/>
		<word name='digestToString'/>
		<word name='disable'/>
		<word name='disconnect'/>
		<word name='div'/>
		<word name='emit'/>
		<word name='encode'/>
		<word name='encodeComponent'/>
		<word name='erf'/>
		<word name='erfc'/>
		<word name='execv'/>
		<word name='exp'/>
		<word name='exp2'/>
		<word name='expandTilde'/>
		<word name='expi'/>
		<word name='expm1'/>
		<word name='extend'/>
		<word name='fabs'/>
		<word name='family'/>
		<word name='fclose'/>
		<word name='fcloseall'/>
		<word name='fdim'/>
		<word name='fdopen'/>
		<word name='feof'/>
		<word name='feqrel'/>
		<word name='ferror'/>
		<word name='fflush'/>
		<word name='fgetc'/>
		<word name='fgetchar'/>
		<word name='fgetpos'/>
		<word name='fgets'/>
		<word name='fgetwc'/>
		<word name='fgetws'/>
		<word name='fileno'/>
		<word name='filesize'/>
		<word name='fill0'/>
		<word name='floor'/>
		<word name='flushall'/>
		<word name='fma'/>
		<word name='fmax'/>
		<word name='fmin'/>
		<word name='fmod'/>
		<word name='fncharmatch'/>
		<word name='fnmatch'/>
		<word name='fopen'/>
		<word name='fprintf'/>
		<word name='fputc'/>
		<word name='fputchar'/>
		<word name='fputs'/>
		<word name='fputwc'/>
		<word name='fputws'/>
		<word name='fread'/>
		<word name='freopen'/>
		<word name='frexp'/>
		<word name='fromMBSz'/>
		<word name='fscanf'/>
		<word name='fseek'/>
		<word name='fsetpos'/>
		<word name='ftell'/>
		<word name='fullCollect'/>
		<word name='fwide'/>
		<word name='fwprintf'/>
		<word name='fwrite'/>
		<word name='fwritef'/>
		<word name='fwritefln'/>
		<word name='fwscanf'/>
		<word name='fxsr'/>
		<word name='genCollect'/>
		<word name='getBaseName'/>
		<word name='getDirName'/>
		<word name='getDrive'/>
		<word name='getExt'/>
		<word name='getGCHandle'/>
		<word name='getName'/>
		<word name='getc'/>
		<word name='getch'/>
		<word name='getchar'/>
		<word name='getche'/>
		<word name='getenv'/>
		<word name='gets'/>
		<word name='getw'/>
		<word name='getwc'/>
		<word name='getwchar_t'/>
		<word name='hasNoPointers'/>
		<word name='hasPointers'/>
		<word name='hyperThreading'/>
		<word name='hypot'/>
		<word name='ia64'/>
		<word name='ilogb'/>
		<word name='inp'/>
		<word name='intel'/>
		<word name='isExpressionTuple'/>
		<word name='isIdentical'/>
		<word name='isStaticArray'/>
		<word name='isUniAlpha'/>
		<word name='isUniLower'/>
		<word name='isUniUpper'/>
		<word name='isabs'/>
		<word name='isalnum'/>
		<word name='isalpha'/>
		<word name='isascii'/>
		<word name='iscntrl'/>
		<word name='isdigit'/>
		<word name='isfinite'/>
		<word name='isgraph'/>
		<word name='isgreater'/>
		<word name='isgreaterequal'/>
		<word name='isinf'/>
		<word name='isless'/>
		<word name='islessequal'/>
		<word name='islessgreater'/>
		<word name='islower'/>
		<word name='isnan'/>
		<word name='isnormal'/>
		<word name='isprint'/>
		<word name='ispunct'/>
		<word name='isspace'/>
		<word name='issubnormal'/>
		<word name='isunordered'/>
		<word name='isupper'/>
		<word name='isxdigit'/>
		<word name='itoa'/>
		<word name='join'/>
		<word name='kbhit'/>
		<word name='ldexp'/>
		<word name='lgamma'/>
		<word name='llrint'/>
		<word name='llround'/>
		<word name='localeconv'/>
		<word name='log'/>
		<word name='log10'/>
		<word name='log1p'/>
		<word name='log2'/>
		<word name='logb'/>
		<word name='lrint'/>
		<word name='lround'/>
		<word name='malloc'/>
		<word name='mblen'/>
		<word name='memchr'/>
		<word name='memcmp'/>
		<word name='memcpy'/>
		<word name='memicmp'/>
		<word name='memmove'/>
		<word name='memset'/>
		<word name='minimize'/>
		<word name='mmx'/>
		<word name='model'/>
		<word name='modf'/>
		<word name='nan'/>
		<word name='nearbyint'/>
		<word name='nextDown'/>
		<word name='nextUp'/>
		<word name='nextafter'/>
		<word name='nexttoward'/>
		<word name='outp'/>
		<word name='perror'/>
		<word name='poly'/>
		<word name='pow'/>
		<word name='printDigest'/>
		<word name='printf'/>
		<word name='processor'/>
		<word name='putc'/>
		<word name='putchar'/>
		<word name='puts'/>
		<word name='putw'/>
		<word name='putwc'/>
		<word name='putwchar_t'/>
		<word name='rand'/>
		<word name='rand_seed'/>
		<word name='read'/>
		<word name='readln'/>
		<word name='realloc'/>
		<word name='remainder'/>
		<word name='remove'/>
		<word name='removeRange'/>
		<word name='removeRoot'/>
		<word name='remquo'/>
		<word name='rename'/>
		<word name='reserve'/>
		<word name='rewind'/>
		<word name='rint'/>
		<word name='rndtol'/>
		<word name='rndtonl'/>
		<word name='round'/>
		<word name='scalbln'/>
		<word name='scalbn'/>
		<word name='scanf'/>
		<word name='setDestDir'/>
		<word name='setGCHandle'/>
		<word name='setMerge'/>
		<word name='setSourceDir'/>
		<word name='setTypeInfo'/>
		<word name='setV1_0'/>
		<word name='setbuf'/>
		<word name='setenv'/>
		<word name='setlocale'/>
		<word name='setvbuf'/>
		<word name='signbit'/>
		<word name='sin'/>
		<word name='sinh'/>
		<word name='spread'/>
		<word name='sprintf'/>
		<word name='sqrt'/>
		<word name='sscanf'/>
		<word name='sse'/>
		<word name='sse2'/>
		<word name='sse3'/>
		<word name='ssse3'/>
		<word name='stepping'/>
		<word name='strcat'/>
		<word name='strchr'/>
		<word name='strcmp'/>
		<word name='strcoll'/>
		<word name='strcpy'/>
		<word name='strcspn'/>
		<word name='strerror'/>
		<word name='strlen'/>
		<word name='strncat'/>
		<word name='strncmp'/>
		<word name='strncpy'/>
		<word name='strpbrk'/>
		<word name='strrchr'/>
		<word name='strspn'/>
		<word name='strstr'/>
		<word name='strtok'/>
		<word name='strxfrm'/>
		<word name='sum'/>
		<word name='swprintf'/>
		<word name='swscanf'/>
		<word name='system'/>
		<word name='tan'/>
		<word name='tanh'/>
		<word name='tempnam'/>
		<word name='tgamma'/>
		<word name='threadsPerCPU'/>
		<word name='tmpfile'/>
		<word name='tmpnam'/>
		<word name='toBytes'/>
		<word name='toMBSz'/>
		<word name='toString'/>
		<word name='toUniLower'/>
		<word name='toUniUpper'/>
		<word name='tolower'/>
		<word name='toupper'/>
		<word name='trunc'/>
		<word name='tuple'/>
		<word name='ungetc'/>
		<word name='ungetwc'/>
		<word name='unlink'/>
		<word name='unsetenv'/>
		<word name='va_start'/>
		<word name='va_arg'/>
		<word name='va_end'/>
		<word name='va_copy'/>
		<word name='vendor'/>
		<word name='vfprintf'/>
		<word name='vfwprintf'/>
		<word name='vprintf'/>
		<word name='vsprintf'/>
		<word name='vswprintf'/>
		<word name='vwprintf'/>
		<word name='wprintf'/>
		<word name='write'/>
		<word name='writef'/>
		<word name='writefln'/>
		<word name='wscanf'/>
	</keywords>
</scheme>

<scheme name='keys'>
	<inherit scheme='keys.custom'/>
	<keywords region='key'>
		<word name='abstract'/>
		<word name='alias'/>
		<word name='align'/>
		<word name='asm'/>
		<word name='assert'/>
		<word name='auto'/>
		<word name='body'/>
		<word name='bool'/>
		<word name='break'/>
		<word name='byte'/>
		<word name='case'/>
		<word name='cast'/>
		<word name='catch'/>
		<word name='cdouble'/>
		<word name='cent'/>
		<word name='cfloat'/>
		<word name='char'/>
		<word name='class'/>
		<word name='const'/>
		<word name='continue'/>
		<word name='creal'/>
		<word name='dchar'/>
		<word name='debug'/>
		<word name='default'/>
		<word name='delegate'/>
		<word name='delete'/>
		<word name='deprecated'/>
		<word name='do'/>
		<word name='double'/>
		<word name='else'/>
		<word name='enum'/>
		<word name='export'/>
		<word name='extern'/>
		<word name='false'/>
		<word name='final'/>
		<word name='finally'/>
		<word name='float'/>
		<word name='for'/>
		<word name='foreach'/>
		<word name='foreach_reverse'/>
		<word name='function'/>
		<word name='goto'/>
		<word name='idouble'/>
		<word name='if'/>
		<word name='ifloat'/>
		<word name='import'/>
		<word name='in'/>
		<word name='inout'/>
		<word name='int'/>
		<word name='interface'/>
		<word name='invariant'/>
		<word name='ireal'/>
		<word name='is'/>
		<word name='lazy'/>
		<word name='long'/>
		<word name='mixin'/>
		<word name='module'/>
		<word name='new'/>
		<word name='null'/>
		<word name='out'/>
		<word name='override'/>
		<word name='package'/>
		<word name='pragma'/>
		<word name='private'/>
		<word name='protected'/>
		<word name='public'/>
		<word name='real'/>
		<word name='return'/>
		<word name='scope'/>
		<word name='short'/>
		<word name='static'/>
		<word name='struct'/>
		<word name='super'/>
		<word name='switch'/>
		<word name='synchronized'/>
		<word name='template'/>
		<word name='this'/>
		<word name='throw'/>
		<word name='true'/>
		<word name='try'/>
		<word name='typedef'/>
		<word name='typeid'/>
		<word name='typeof'/>
		<word name='ubyte'/>
		<word name='ucent'/>
		<word name='uint'/>
		<word name='ulong'/>
		<word name='union'/>
		<word name='unittest'/>
		<word name='ushort'/>
		<word name='version'/>
		<word name='void'/>
		<word name='volatile'/>
		<word name='wchar'/>
		<word name='while'/>
		<word name='with'/>
	</keywords>
</scheme>

</type>
</hrc>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Colorer Library.
   -
   - The Initial Developer of the Original Code is
   - Eugene Efremov <4mirror@mail.ru>
   - Portions created by the Initial Developer are Copyright (C) 2006-2008
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   - Vladimir Panteleev <thecybershadow@gmail.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->
